import json
import subprocess
import os
from pathlib import Path

# I de identacion mayor, i de identación menor, s de separador
I = "      "  # 6 espacios de indentación para el código F90
i = "  "
s = "!______________________________________________________________________"


class F90Serializer:
    def __init__(self):
        self.f90_lines = ["! Generated by PrePRODIC3D"]
        self.loop_mapping = {
            "X Max": ("L1", "J", "M1", "K", "N1", "(L1,J,K)"),
            "X Min": ("I1", "J", "M1", "K", "N1", "(1,J,K)"),
            "Y Max": ("M1", "I", "L1", "K", "N1", "(I,M1,K)"),
            "Y Min": ("J1", "I", "L1", "K", "N1", "(I,1,K)"),
            "Z Max": ("N1", "I", "L1", "J", "M1", "(I,J,N1)"),
            "Z Min": ("K1", "I", "L1", "J", "M1", "(I,J,1)"),
        }

    def serialize_grid_section(self, grid, header):
        """
        Serializa la sección GRID del JSON a líneas de código F90, incluyendo los datos de HEADER.

        :param grid: Diccionario con la información de la sección GRID del JSON.
        :param header: Diccionario con la información de la sección HEADER del JSON.
        :return: Lista de líneas de código F90 correspondientes a la sección GRID y HEADER.
        """
        f90_lines = ["ENTRY GRID"]
        # HEADER section
        for key, f90_key in [("le_titulosimu", "HEADER"), ("le_tituloimpre", "PRINTF"), ("le_titulograf", "PLOTF")]:
            if key in header:
                f90_lines.append(f"{f90_key}='{header[key]}'")
        mode = {"Cartesianas": 1, "Cilindricas": 2}.get(grid.get("cb_tipocoord", "Cartesianas"))
        kcy = 1 if grid.get("cb_tiposistema", "Cerrado") == "Abierto" else 0
        f90_lines.append(f"MODE={mode} ; KCY={kcy}")
        coord_vars = {
            1: {"XL": "le_xlon", "YL": "le_ylon", "ZL": "le_zlon"},
            2: {"XL": "le_titalon", "R(1)": "le_rini", "YL": "le_rlon", "ZL": "le_zloncil"},
        }
        nvc_vars = {
            1: {"NCVLX": "le_nvcx", "NCVLY": "le_nvcy", "NCVLZ": "le_nvcz"},
            2: {"NCVLX": "le_nvctita", "NCVLY": "le_nvcr", "NCVLZ": "le_nvczcil"},
        }
        for group in (coord_vars, nvc_vars):
            group_lines = []
            for var, key in group[mode].items():
                if key and key in grid:
                    group_lines.append(f"{var}={grid[key]}")
            if group_lines:
                f90_lines.append(" ; ".join(group_lines))
        grid_function = "ZGRID" if grid.get("cb_tipozonas", "") == "Varias zonas" else "EZGRID"
        f90_lines.append(f"CALL {grid_function}")
        f90_lines.append("RETURN")
        return f90_lines

    def serialize_begin_section(self, grid, variables, bound, values, output):
        f90_lines = ["ENTRY BEGIN"]
        for num in range(1, 12):
            var_title = variables.get(f"le_var_title{num}")
            if var_title is not None and var_title != "":
                f90_lines.append(f"TITLE({num})='{var_title}'")
        for num in range(1, 11):
            if variables.get(f"chb_ksolve{num}") == 2:
                f90_lines.append(f"KSOLVE({num})=1")
        for num in range(1, 12):
            if variables.get(f"chb_kprint{num}") == 2:
                f90_lines.append(f"KPRINT({num})=1")
        for num in range(1, 12):
            var_name = f"le_var_title{num}"
            if var_name in values:
                num = int("".join(filter(str.isdigit, var_name)))
                if values[var_name].get("chb_iborx") == 2:
                    f90_lines.append(f"IBORX({num})=1")
                if values[var_name].get("chb_ibory") == 2:
                    f90_lines.append(f"IBORY({num})=1")
                if values[var_name].get("chb_iborz") == 2:
                    f90_lines.append(f"IBORZ({num})=1")
                if values[var_name].get("chb_ipun") == 2:
                    f90_lines.append(f"IPUN({num})=1")
                ixyz = values[var_name].get("le_ixyz")
                if ixyz is not None and ixyz != "":
                    f90_lines.append(f"IXYZ({num})={ixyz}")
        for num in range(1, 12):
            relax = variables.get(f"le_relax{num}")
            if relax is not None and relax != "":
                f90_lines.append(f"RELAX({num})={relax}")
        tolerance = output.get("le_tol")
        if tolerance is not None and tolerance != "":
            f90_lines.append(f"TOL={tolerance}")
        kord = 2 if grid.get("cb_trataborde", "Esquema de bajo orden") == "Esquema de alto orden" else 1
        last = int(output.get("le_last", 5))
        f90_lines.append(f"KORD={kord}")
        f90_lines.append(f"LAST={last}")
        if "le_var_title5" in values and "le_general_value" in values["le_var_title5"]:
            f90_lines.extend(
                [
                    "DO I=1,L1",
                    f"{i}DO J=1,M1",
                    f"{i}{i}DO K=1,N1",
                    f"{i}{i}{i}T(I,J,K)={values['le_var_title5']['le_general_value']}",
                    f"{i}{i}ENDDO",
                    f"{i}ENDDO",
                    "ENDDO",
                ]
            )
        if "le_var_title1" in values and "le_general_value" in values["le_var_title1"]:
            f90_lines.extend(
                [
                    "DO I=1,L1",
                    f"{i}DO J=1,M1",
                    f"{i}{i}DO K=1,N1",
                    f"{i}{i}{i}U(I,J,K)={values['le_var_title1']['le_general_value']}",
                    f"{i}{i}ENDDO",
                    f"{i}ENDDO",
                    "ENDDO",
                ]
            )
        if "le_var_title2" in values and "le_general_value" in values["le_var_title2"]:
            f90_lines.extend(
                [
                    "DO I=1,L1",
                    f"{i}DO J=1,M1",
                    f"{i}{i}DO K=1,N1",
                    f"{i}{i}{i}V(I,J,K)={values['le_var_title2']['le_general_value']}",
                    f"{i}{i}ENDDO",
                    f"{i}ENDDO",
                    "ENDDO",
                ]
            )
        if "le_var_title3" in values and "le_general_value" in values["le_var_title3"]:
            f90_lines.extend(
                [
                    "DO I=1,L1",
                    f"{i}DO J=1,M1",
                    f"{i}{i}DO K=1,N1",
                    f"{i}{i}{i}W(I,J,K)={values['le_var_title3']['le_general_value']}",
                    f"{i}{i}ENDDO",
                    f"{i}ENDDO",
                    "ENDDO",
                ]
            )
        for boundary, patchs in bound.items():
            for patch, values in patchs.items():
                value_condition = values.get("chb_value", None)
                border_value = values.get("le_value", None)
                velocity_u = values.get("le_value_veloc_u", None)
                velocity_v = values.get("le_value_veloc_v", None)
                velocity_w = values.get("le_value_veloc_w", None)
                conditions = [border_value, velocity_u, velocity_v, velocity_w]
                if value_condition == 2 and any(conditions):
                    _, loop_var_1, loop_limit_1, loop_var_2, loop_limit_2, indexes = self.loop_mapping[boundary]
                    f90_lines.extend(
                        [
                            f"DO {loop_var_1}=1,{loop_limit_1}",
                            f"{i}DO {loop_var_2}=1,{loop_limit_2}",
                        ]
                    )
                    if velocity_u:
                        f90_lines.append(f"{i}{i}U{indexes}={velocity_u}")
                    if velocity_v:
                        f90_lines.append(f"{i}{i}V{indexes}={velocity_v}")
                    if velocity_w:
                        f90_lines.append(f"{i}{i}W{indexes}={velocity_w}")
                    if border_value:
                        f90_lines.append(f"{i}{i}T{indexes}={border_value}")
                    f90_lines.extend(
                        [
                            f"{i}ENDDO",
                            "ENDDO",
                        ]
                    )
        f90_lines.append("RETURN")
        return f90_lines

    def serialize_dense_section(self, dense):
        f90_lines = ["ENTRY DENSE"]
        f90_lines.append("RETURN")
        return f90_lines

    def serialize_bound_section(self, bound):
        f90_lines = ["ENTRY BOUND"]
        f90_lines.append("RETURN")
        return f90_lines

    def serialize_output_section(self, output):
        f90_lines = ["ENTRY OUTPUT"]
        f90_lines.append("RETURN")
        return f90_lines

    def serialize_phi_section(self, variables, bound, values):
        f90_lines = ["ENTRY PHI"]
        if "Temperatura" in values and "le_k" in values["Temperatura"]:
            f90_lines.extend(
                [
                    "DO I=2,L2",
                    f"{i}DO J=2,M2",
                    f"{i}{i}DO K=2,N2",
                    f"{i}{i}{i}GAM(I,J,K)={values['Temperatura']['le_k']}",
                    f"{i}{i}ENDDO",
                    f"{i}ENDDO",
                    "ENDDO",
                ]
            )
            if "chb_local_value" in values["Temperatura"]:
                if "Region 1" in values["Temperatura"] and "le_local_value" in values["Temperatura"]["Region 1"]:
                    f90_lines.extend(
                        [
                            "DO I=2,L2",
                            f"{i}DO J=2,M2",
                            f"{i}{i}DO K=2,N2",
                            f"{i}{i}{i}SC(I,J,K)={values['Temperatura']['Region 1']['le_local_value']}",
                            f"{i}{i}ENDDO",
                            f"{i}ENDDO",
                            "ENDDO",
                        ]
                    )
        for boundary, patches in bound.items():
            for patch, values in patches.items():
                flux_condition = values.get("chb_flux", 0)
                if flux_condition == 2:
                    phi_var, loop_var_1, loop_limit_1, loop_var_2, loop_limit_2, _ = self.loop_mapping[boundary]
                    ambient_temp = values.get("le_tempamb")
                    f90_lines.append(f"DO {loop_var_1}=1,{loop_limit_1}")
                    f90_lines.append(f"{i}DO {loop_var_2}=1,{loop_limit_2}")
                    if ambient_temp is not None:
                        f90_lines.append(
                            f"{i}{i}KBC{phi_var}({loop_var_1},{loop_var_2})=2; FLXC{phi_var}({loop_var_1},{loop_var_2})={ambient_temp}"
                        )
                    else:
                        f90_lines.append(f"{i}{i}KBC{phi_var}({loop_var_1},{loop_var_2})=2")
                    f90_lines.append(f"{i}ENDDO")
                    f90_lines.append("ENDDO")
        f90_lines.append("RETURN")
        f90_lines.append("END")
        return f90_lines

    def generate_f90(self, config_structure):
        self.extend_f90(["SUBROUTINE ADAPT"])
        self.extend_f90(["INCLUDE '3DCOMMON.F90'"])

        # HEADER y GRID section - Usando la función definida anteriormente
        grid_section_lines = self.serialize_grid_section(
            config_structure.get("GRID", {}), config_structure.get("HEADER", {})
        )
        self.extend_f90(grid_section_lines)
        begin_section_lines = self.serialize_begin_section(
            config_structure.get("GRID", {}),
            config_structure.get("VARIABLES", {}),
            config_structure.get("BOUND", {}),
            config_structure.get("VALUES", {}),
            config_structure.get("OUTPUT", {}),
        )
        self.extend_f90(begin_section_lines)
        dense_section_lines = self.serialize_dense_section("")
        self.extend_f90(dense_section_lines)
        bound_section_lines = self.serialize_bound_section("")
        self.extend_f90(bound_section_lines)
        output_section_lines = self.serialize_output_section("")
        self.extend_f90(output_section_lines)
        phi_section_lines = self.serialize_phi_section(
            config_structure.get("VARIABLES", {}), config_structure.get("BOUND", {}), config_structure.get("VALUES", {})
        )
        self.extend_f90(phi_section_lines)

        print(self.f90_lines)
        return "\n".join(self.f90_lines)

    def extend_f90(self, new_f90_lines):
        new_f90_lines = [f"{I}{line}" for line in new_f90_lines]
        self.f90_lines.extend([s] + new_f90_lines)


if __name__ == "__main__":
    working_directory = Path("C:/PRODIC3D/Utilidades/F90/dona")
    os.chdir(working_directory)
    with open("dona.json", "r", encoding="utf-8") as f:
        json_data = json.load(f)
    serializer = F90Serializer()
    f90_code = serializer.generate_f90(json_data)
    with open(working_directory / "output.f90", "w", encoding="utf-8") as f:
        f.write(f90_code)
    exe_path = working_directory / "myprogram.exe"
    if exe_path.exists():
        exe_path.unlink()
    compile_command = "gfortran -o myprogram.exe prodic3d.f90 output.f90"
    subprocess.run(compile_command, check=True, shell=True, cwd=working_directory)
    subprocess.run(str(exe_path), shell=True, check=False)
    ruta_paraview = "C:/Program Files/ParaView 5.12.0/bin/paraview.exe"
    script_path = "C:/PREPRODIC3D/tecplot.py"
    subprocess.run([ruta_paraview, "--script=" + script_path], check=True)
